{"ast":null,"code":"import cleanArray from '../utils/cleanArray';\nimport sendCursorToEnd from '../utils/sendCursorToEnd';\n/**\n * Scrolls command history in a given direction\n * @param {String} direction Direction to scroll in ('up' or 'down')\n * @param {Object} options\n * @param {Array} options.history - Array of previous inputs from the user\n * @param {Number} options.historyPosition - Current position in the history\n * @param {Number} options.previousHistoryPosition - Previous position in the history\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\n */\n\nexport default ((direction, options) => {\n  const {\n    history,\n    historyPosition,\n    previousHistoryPosition,\n    terminalInput\n  } = options; // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n\n  const commandHistory = cleanArray(history).reverse();\n  const position = historyPosition;\n  const previousPosition = previousHistoryPosition;\n  const terminal = terminalInput.current;\n\n  if (commandHistory.length > 0) {\n    // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          const latest = commandHistory[0];\n          const first = commandHistory[commandHistory.length - 1];\n          const next = commandHistory[position + 1];\n\n          if (position === null) {\n            // If at no yet defined position, get most recent entry\n            terminal.value = latest;\n            sendCursorToEnd(terminal);\n            return {\n              historyPosition: 0,\n              previousHistoryPosition: null\n            };\n          } else if (position + 1 === commandHistory.length) {\n            // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n            // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n            // Hence why in one-unit histories the previous position has to be set to null, not 0\n            terminal.value = first;\n            sendCursorToEnd(terminal);\n            return {\n              historyPosition: commandHistory.length - 1,\n              previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n            };\n          } else {\n            // Normal increment by one\n            terminal.value = next;\n            sendCursorToEnd(terminal);\n            return {\n              historyPosition: position + 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n\n      case 'down':\n        {\n          // Declaring variables for these here to better clarify this block which can get pretty convoluted\n          const latest = commandHistory[0];\n          const empty = '';\n          const next = commandHistory[position - 1];\n\n          if (position === null || !commandHistory[position]) {\n            // If at initial or out of range, clear (Unix-like behaviour)\n            terminal.value = empty;\n            sendCursorToEnd(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else if (position - 1 === -1) {\n            // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n            if (previousPosition === null || position === 0 && previousPosition === 1) terminal.value = empty;else terminal.value = latest;\n            sendCursorToEnd(terminal);\n            return {\n              historyPosition: null,\n              previousHistoryPosition: null\n            };\n          } else {\n            // Normal decrement by one\n            terminal.value = next;\n            sendCursorToEnd(terminal);\n            return {\n              historyPosition: position - 1,\n              previousHistoryPosition: position\n            };\n          }\n        }\n    }\n  }\n});","map":{"version":3,"sources":["D:/DEV/Github/freezingkas.com/freezingkas/src/components/terminal/handlers/scrollHistory.js"],"names":["cleanArray","sendCursorToEnd","direction","options","history","historyPosition","previousHistoryPosition","terminalInput","commandHistory","reverse","position","previousPosition","terminal","current","length","latest","first","next","value","empty"],"mappings":"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","sourcesContent":["import cleanArray from '../utils/cleanArray'\nimport sendCursorToEnd from '../utils/sendCursorToEnd'\n\n/**\n * Scrolls command history in a given direction\n * @param {String} direction Direction to scroll in ('up' or 'down')\n * @param {Object} options\n * @param {Array} options.history - Array of previous inputs from the user\n * @param {Number} options.historyPosition - Current position in the history\n * @param {Number} options.previousHistoryPosition - Previous position in the history\n * @param {React.Ref} options.terminalInput - Ref to the terminal input element\n */\nexport default (direction, options) => {\n  const { history, historyPosition, previousHistoryPosition, terminalInput } = options\n\n  // BUG: I have to duplicate sendCursorToEnd for each condition, because doing so in a catch-all manner doesn't seem to work at all\n\n  // Clean potential empty items and reverse order to ease position tracking\n  // (Reverse = starting from the newest first when going up and vice versa)\n  const commandHistory = cleanArray(history).reverse()\n  const position = historyPosition\n  const previousPosition = previousHistoryPosition\n  const terminal = terminalInput.current\n\n  if (commandHistory.length > 0) { // Only run if history is non-empty and in use\n    switch (direction) {\n      case 'up': {\n        // Declaring variables for these here to better clarify this block which can get pretty convoluted\n        const latest = commandHistory[0]\n        const first = commandHistory[commandHistory.length - 1]\n        const next = commandHistory[position + 1]\n\n        if (position === null) {\n          // If at no yet defined position, get most recent entry\n          terminal.value = latest\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: 0,\n            previousHistoryPosition: null\n          }\n        } else if (position + 1 === commandHistory.length) {\n          // If the first entry will be reached on this press, get it and decrement position by 1 to avoid confusing downscroll\n          // EXCEPT: If there is only 1 unit in the history, our previous position was actually null, not zero as defined above\n          // Hence why in one-unit histories the previous position has to be set to null, not 0\n          terminal.value = first\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: commandHistory.length - 1,\n            previousHistoryPosition: commandHistory.length === 1 ? null : commandHistory.length - 2\n          }\n        } else {\n          // Normal increment by one\n          terminal.value = next\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: position + 1,\n            previousHistoryPosition: position\n          }\n        }\n      }\n      case 'down': {\n        // Declaring variables for these here to better clarify this block which can get pretty convoluted\n        const latest = commandHistory[0]\n        const empty = ''\n        const next = commandHistory[position - 1]\n\n        if (position === null || !commandHistory[position]) {\n          // If at initial or out of range, clear (Unix-like behaviour)\n          terminal.value = empty\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: null,\n            previousHistoryPosition: null\n          }\n        } else if (position - 1 === -1) {\n          // Clear because user is either pressing up once and is now pressing down again, or is reaching the latest entry\n          if (previousPosition === null || (position === 0 && previousPosition === 1)) terminal.value = empty\n          else terminal.value = latest\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: null,\n            previousHistoryPosition: null\n          }\n        } else {\n          // Normal decrement by one\n          terminal.value = next\n          sendCursorToEnd(terminal)\n\n          return {\n            historyPosition: position - 1,\n            previousHistoryPosition: position\n          }\n        }\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}